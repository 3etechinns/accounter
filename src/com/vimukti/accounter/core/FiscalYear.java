package com.vimukti.accounter.core;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Iterator;
import java.util.List;

import org.hibernate.CallbackException;
import org.hibernate.Query;
import org.hibernate.Session;
import org.hibernate.classic.Lifecycle;

import com.vimukti.accounter.core.change.ChangeTracker;
import com.vimukti.accounter.services.SessionUtils;
import com.vimukti.accounter.utils.HibernateUtil;
import com.vimukti.accounter.utils.SecureUtils;
import com.vimukti.accounter.web.client.InvalidOperationException;
import com.vimukti.accounter.web.client.core.AccounterCommand;
import com.vimukti.accounter.web.client.core.AccounterCoreType;

public class FiscalYear implements IAccounterServerCore, Lifecycle,
		ICreatableObject {
	/**
	 * 
	 */
	private static final long serialVersionUID = -3871302599394319194L;
	public static final int STATUS_OPEN = 1;
	public static final int STATUS_CLOSE = 2;

	/**
	 * A unique, number, generated by Hibernate, across Finance
	 */
	long id;

	/**
	 * A 40 Digit, Secure Random Number,
	 */
	public String stringID;

	/**
	 * The StartDate for the Fiscal Year
	 */
	FinanceDate startDate;

	/**
	 * The End Date for the Fiscal Year
	 */
	FinanceDate endDate;

	/**
	 * Fiscal Year status, either STATUS_OPEN or STATUS_CLOSE
	 */
	int status = STATUS_OPEN;

	boolean isCurrentFiscalYear = Boolean.FALSE;

	/**
	 * Previous Start Date
	 */
	transient FinanceDate previousStartDate;

	int version;

	transient int previousStatus;

	transient boolean isImported;

	String createdBy;
	String lastModifier;
	FinanceDate createdDate;
	FinanceDate lastModifiedDate;

	boolean isDefault;
	transient private boolean isOnSaveProccessed;
	transient FinanceDate previousEndDate;

	public FiscalYear() {
		// TODO
	}

	public int getVersion() {
		return version;
	}

	public void setVersion(int version) {
		this.version = version;
	}

	public FiscalYear(FinanceDate startDate, FinanceDate endDate, int status,
			boolean isCurrentFiscalYear) {

		this.startDate = startDate;
		this.endDate = endDate;
		this.status = status;
		this.isCurrentFiscalYear = isCurrentFiscalYear;

	}

	/**
	 * @return the id
	 */
	public long getId() {
		return id;
	}

	/**
	 * @param id
	 *            the id to set
	 */
	public void setId(long id) {
		this.id = id;
	}

	/**
	 * @return the startDate
	 */
	public FinanceDate getStartDate() {
		return startDate;
	}

	/**
	 * @param startDate
	 *            the startDate to set
	 */
	public void setStartDate(FinanceDate startDate) {
		this.startDate = startDate;
	}

	/**
	 * @return the endDate
	 */
	public FinanceDate getEndDate() {
		return endDate;
	}

	/**
	 * @param endDate
	 *            the endDate to set
	 */
	public void setEndDate(FinanceDate endDate) {
		this.endDate = endDate;
	}

	/**
	 * @return the status
	 */
	public int getStatus() {
		return status;
	}

	/**
	 * @param status
	 *            the status to set
	 */
	public void setStatus(int status) {
		this.status = status;
	}

	/**
	 * @return the isCurrentFiscalYear
	 */
	public boolean getIsCurrentFiscalYear() {
		return isCurrentFiscalYear;
	}

	/**
	 * @param isCurrentFiscalYear
	 *            the isCurrentFiscalYear to set
	 */
	public void setIsCurrentFiscalYear(boolean isCurrentFiscalYear) {
		this.isCurrentFiscalYear = isCurrentFiscalYear;
	}

	public FinanceDate getPreviousStartDate() {
		return previousStartDate;
	}

	public void setPreviousStartDate(FinanceDate previousStartDate) {
		this.previousStartDate = previousStartDate;
	}

	/**
	 * @return the isDefault
	 */
	public boolean isDefault() {
		return isDefault;
	}

	/**
	 * @param isDefault
	 *            the isDefault to set
	 */
	public void setDefault(boolean isDefault) {
		this.isDefault = isDefault;
	}

	@Override
	public boolean onDelete(Session s) throws CallbackException {
		AccounterCommand accounterCore = new AccounterCommand();
		accounterCore.setCommand(AccounterCommand.DELETION_SUCCESS);
		accounterCore.setStringID(stringID);
		accounterCore.setObjectType(AccounterCoreType.FISCALYEAR);
		ChangeTracker.put(accounterCore);
		return false;
	}

	@Override
	public void onLoad(Session s, Serializable id) {
		this.previousStartDate = this.startDate;
		this.previousStatus = this.status;
		this.previousEndDate = this.endDate;
	}

	@Override
	public boolean onSave(Session session) throws CallbackException {

		this.stringID = this.stringID == null || this.stringID != null
				&& this.stringID.isEmpty() ? SecureUtils.createID()
				: this.stringID;

		if (isImported) {
			return false;
		}
		if (this.isOnSaveProccessed)
			return true;
		this.isOnSaveProccessed = true;
		// this.setPreviousStartDate(this.getStartDate());
		this.setStatus(FiscalYear.STATUS_OPEN);
		Utility.updateCurrentFiscalYear();
		onUpdate(session);
		ChangeTracker.put(this);
		return false;
	}

	@SuppressWarnings("unchecked")
	@Override
	public boolean onUpdate(Session session) throws CallbackException {

		if (this.previousStatus == STATUS_OPEN && this.status == STATUS_CLOSE) {

			SessionUtils.update(this, session);
			// move the Net Income to the Retain Earnings Account and updating
			// the Income and Expense accounts balances accordingly.

			Query query = session.getNamedQuery("getNetIncome").setParameter(
					"startDate", this.previousStartDate.getTime())
					.setParameter("endDate", this.endDate.getTime());

			List list = query.list();
			double netIncome = 0;
			if (list != null && list.size() > 0) {
				netIncome = list.get(0) == null ? 0.0 : (Double) list.get(0);

				Query q = session
						.createQuery(
								"select at.account.id as accountId, sum(at.amount) as amount from com.vimukti.accounter.core.AccountTransaction at where at.account.type in (14,15,16,17,18) and at.transaction.transactionDate between :startDate and :endDate group by at.account.id")
						.setParameter("startDate", this.previousStartDate)
						.setParameter("endDate", this.endDate);

				List list1 = q.list();
				Object[] object = null;
				List<AccountTransactionByAccount> accountTransactionList = new ArrayList<AccountTransactionByAccount>();
				Iterator it = list1.iterator();
				while (it.hasNext()) {
					object = (Object[]) it.next();
					AccountTransactionByAccount accountTransactionByTaxAccount = new AccountTransactionByAccount();
					accountTransactionByTaxAccount
							.setAccount(object[0] != null ? (Account) session
									.get(Account.class, (Long) object[0])
									: null);
					accountTransactionByTaxAccount
							.setAmount(object[1] != null ? (Double) object[1]
									: 0.0);
					accountTransactionList.add(accountTransactionByTaxAccount);
				}

				// Query nextTransactionNumberQuery = session
				// .getNamedQuery("getNextTransactionNumber");
				// nextTransactionNumberQuery.setLong("type",
				// Transaction.TYPE_JOURNAL_ENTRY);
				// List l = nextTransactionNumberQuery.list();
				// long nextTransactionNumber = 1;
				// if (l != null && l.size() > 0) {
				// nextTransactionNumber = ((Long) l.get(0)).longValue() + 1;
				// }
				String nextTransactionNumber = NumberUtils
						.getNextTransactionNumber(Transaction.TYPE_JOURNAL_ENTRY);
				// One Journal Entry for this closing Fiscal Year.
				// Journal Entries for Income and Expenses Accounts for the
				// above amount adjustments
				JournalEntry journalEntry = new JournalEntry(this, netIncome,
						accountTransactionList, nextTransactionNumber,
						JournalEntry.TYPE_NORMAL_JOURNAL_ENTRY);
				session.save(journalEntry);

				List<AccountTransactionByAccount> cashBasisAccountEntries = new ArrayList<AccountTransactionByAccount>();
				for (AccountTransactionByAccount accountTransactionByAccount : accountTransactionList) {
					if (accountTransactionByAccount.getAccount().isConsiderAsCashAccount
							&& !(accountTransactionByAccount
									.getAccount()
									.getName()
									.equals(
											AccounterConstants.OTHER_CASH_INCOME) || accountTransactionByAccount
									.getAccount()
									.getName()
									.equals(
											AccounterConstants.OTHER_CASH_EXPENSE))) {
						cashBasisAccountEntries
								.add(accountTransactionByAccount);
					}
				}

				if (cashBasisAccountEntries.size() > 0) {

					JournalEntry cashBasisJournalEntry = new JournalEntry(
							this,
							cashBasisAccountEntries,
							NumberUtils
									.getStringwithIncreamentedDigit(nextTransactionNumber),
							JournalEntry.TYPE_CASH_BASIS_JOURNAL_ENTRY);
					session.save(cashBasisJournalEntry);
				}

			}
		} else if (this.getPreviousStartDate() != null && this.getStartDate().equals(this.getPreviousStartDate())) {
			session.saveOrUpdate(this);
		} else if ((this.getPreviousStartDate() != null && !this.getStartDate()
				.equals(this.getPreviousStartDate()))
				|| this.getPreviousStartDate() == null) {
			Company company = Company.getCompany();
			if (company != null) {
				company.getPreferences().setStartDate(this.startDate);
				company.getPreferences().setPreventPostingBeforeDate(
						this.startDate);
				session.saveOrUpdate(company);
				this
						.setEndDate(getEndDateForStartDate(this.startDate
								.getTime()));
				checkIsCurrentFY(this);
				session.saveOrUpdate(this);
				addOrUpdateFiscalYears(this);
			}
		}
		// else if (!this.getStartDate().equals(this.getPreviousStartDate())) {
		//
		// List<FiscalYear> list = new ArrayList<FiscalYear>();
		// Date modifiedStartDate = this.getStartDate();
		// Date existingLeastStartDate = modifiedStartDate;
		// Date existingHighestEndDate = modifiedStartDate;
		// Boolean exist = Boolean.FALSE;
		// list = session
		// .createQuery(
		// "from com.vimukti.accounter.core.FiscalYear f order by f.startDate")
		// .list();
		// if (list.size() > 0) {
		// Iterator<FiscalYear> i = list.iterator();
		// // if (i.hasNext()) {
		// // FiscalYear fs = (FiscalYear) i.next();
		// // existingLeastStartDate = fs.getStartDate();
		// // existingHighestEndDate = fs.getEndDate();
		// // }
		// // i = list.iterator();
		// // while (i.hasNext()) {
		// // FiscalYear fs = (FiscalYear) i.next();
		// // if (modifiedStartDate.after(fs.getStartDate())
		// // && modifiedStartDate.before(fs.getEndDate())) {
		// // exist = Boolean.TRUE;
		// // break;
		// // }
		// // if (fs.getStartDate().before(existingLeastStartDate)) {
		// // existingLeastStartDate = fs.getStartDate();
		// // }
		// // if (fs.getEndDate().after(existingHighestEndDate)) {
		// // existingHighestEndDate = fs.getEndDate();
		// // }
		// //
		// // }
		// FiscalYear firstFiscalYear = list.get(0) != null ? list.get(0)
		// : null;
		// FiscalYear lastFiscalYear = null;
		// while (i.hasNext()) {
		// lastFiscalYear = (FiscalYear) i.next();
		// }
		// existingLeastStartDate = firstFiscalYear.getPreviousStartDate();
		//
		// existingHighestEndDate = lastFiscalYear.getEndDate();
		//
		// if ((modifiedStartDate.before(existingLeastStartDate) ||
		// modifiedStartDate
		// .after(existingHighestEndDate))) {
		// Calendar cal = Calendar.getInstance();
		// cal.setTime(modifiedStartDate);
		// Integer modifiedYear = cal.get(Calendar.YEAR);
		//
		// cal.setTime(existingLeastStartDate);
		// Integer existingLeastYear = cal.get(Calendar.YEAR);
		//
		// cal.setTime(existingHighestEndDate);
		// Integer existingHighestYear = cal.get(Calendar.YEAR);
		// if (modifiedStartDate.before(existingLeastStartDate)) {
		// int diff = existingLeastYear - modifiedYear;
		// for (int k = 0; k < diff; k++) {
		//
		// cal.set(modifiedYear + k, 0, 1);
		// Date startDate = cal.getTime();
		//
		// cal.set(modifiedYear + k, 11, 31);
		// Date endDate = cal.getTime();
		//
		// FiscalYear fs = new FiscalYear(startDate, endDate,
		// FiscalYear.STATUS_OPEN, Boolean.FALSE);
		// session.save(fs);
		// }
		//
		// } else if (modifiedStartDate.after(existingHighestEndDate)) {
		// int diff = modifiedYear - existingHighestYear;
		// for (int k = 1; k <= diff; k++) {
		// cal.set(existingHighestYear + k, 0, 1);
		// Date startDate = cal.getTime();
		//
		// cal.set(existingHighestYear + k, 11, 31);
		// Date endDate = cal.getTime();
		// FiscalYear fs = new FiscalYear(startDate, endDate,
		// FiscalYear.STATUS_OPEN, Boolean.FALSE);
		// session.save(fs);
		// }
		// }
		//
		// }
		// this.setStartDate(this.getPreviousStartDate());
		// session.saveOrUpdate(this);
		//
		// Company company = Company.getCompany();
		// company.getPreferences().setStartDate(this.startDate);
		// company.getPreferences().setPreventPostingBeforeDate(
		// this.startDate);
		// session.saveOrUpdate(company);
		// }
		// }
		this.setPreviousStartDate(this.getStartDate());
		Utility.updateCurrentFiscalYear();
		ChangeTracker.put(this);
		return false;
	}

	@Override
	public String getStringID() {
		return this.stringID;
	}

	@Override
	public void setStringID(String stringID) {
		this.stringID = stringID;

	}

	@Override
	public void setImported(boolean isImported) {
		this.isImported = isImported;

	}

	public void setCreatedBy(String createdBy) {
		this.createdBy = createdBy;
	}

	public String getCreatedBy() {
		return createdBy;
	}

	public void setLastModifier(String lastModifier) {
		this.lastModifier = lastModifier;
	}

	public String getLastModifier() {
		return lastModifier;
	}

	public void setCreatedDate(FinanceDate createdDate) {
		this.createdDate = createdDate;
	}

	public FinanceDate getCreatedDate() {
		return createdDate;
	}

	public void setLastModifiedDate(FinanceDate lastModifiedDate) {
		this.lastModifiedDate = lastModifiedDate;
	}

	public FinanceDate getLastModifiedDate() {
		return lastModifiedDate;
	}

	@Override
	public boolean canEdit(IAccounterServerCore clientObject)
			throws InvalidOperationException {
		// TODO Auto-generated method stub
		return true;
	}

	public boolean canDelete(FiscalYear object)
			throws InvalidOperationException {
		Session session = HibernateUtil.getCurrentSession();
		List list = session
				.createQuery(
						"from com.vimukti.accounter.core.Transaction t where t.transactionDate between :startDate and :endDate")
				.setParameter("startDate", object.getStartDate()).setParameter(
						"endDate", object.getEndDate()).list();
		if (list != null && list.size() != 0)
			throw new InvalidOperationException(
					"You already created some transaction in this period, You can't delete");
		return true;
	}

	private void addOrUpdateFiscalYears(FiscalYear presentFiscalYear) {
		modifyFiscalYears(presentFiscalYear);
		Session session = HibernateUtil.getCurrentSession();
		List transactionDates = session
				.createQuery(
						"select t.transactionDate from com.vimukti.accounter.core.Transaction t where t.transactionDate<:date")
				.setParameter("date", this.getStartDate()).list();
		Iterator it = transactionDates.iterator();
		while (it.hasNext()) {
			FinanceDate date = (FinanceDate) it.next();
			createFiscalYearForExistingTransactions(date);
		}
	}

	private void modifyFiscalYears(FiscalYear presentFiscalYear) {
		Session s = HibernateUtil.getCurrentSession();
		List<FiscalYear> beforeFYs = s
				.createQuery(
						"from com.vimukti.accounter.core.FiscalYear f where f.id !=:id and f.startDate<:startDate order by f.startDate desc")
				.setParameter("id", this.getId()).setParameter("startDate",
						this.getStartDate()).list();
		Calendar tempCal = Calendar.getInstance();
		tempCal.setTime(this.getStartDate().getAsDateObject());
		for (FiscalYear fYear : beforeFYs) {
			Calendar cal = Calendar.getInstance();

			cal.setTime(tempCal.getTime());
			cal.set(Calendar.MONTH, tempCal.get(Calendar.MONTH) - 12);

			FinanceDate startDate = new FinanceDate(cal.getTime());
			fYear.setStartDate(startDate);
			fYear.setEndDate(getEndDateForStartDate(startDate.getTime()));
			checkIsCurrentFY(fYear);
			s.saveOrUpdate(fYear);
			ChangeTracker.put(fYear);
			tempCal.setTime(startDate.getAsDateObject());
		}
		List<FiscalYear> afterFYs = s
				.createQuery(
						"from com.vimukti.accounter.core.FiscalYear f where f.id !=:id and f.startDate>=:startDate order by f.startDate")
				.setParameter("id", this.id).setParameter("startDate",
						this.getStartDate()).list();
		tempCal.setTime(this.getStartDate().getAsDateObject());
		for (FiscalYear fYear : afterFYs) {
			Calendar cal = Calendar.getInstance();

			cal.setTime(tempCal.getTime());
			cal.set(Calendar.MONTH, tempCal.get(Calendar.MONTH) + 12);
			FinanceDate startDate = new FinanceDate(cal.getTime());
			fYear.setStartDate(startDate);
			fYear.setEndDate(getEndDateForStartDate(startDate.getTime()));
			checkIsCurrentFY(fYear);
			s.saveOrUpdate(fYear);
			ChangeTracker.put(fYear);
			tempCal.setTime(startDate.getAsDateObject());
		}
	}

	private FinanceDate getEndDateForStartDate(long startDate) {
		FinanceDate date = new FinanceDate(startDate);
		date.setYear(date.getYear() + 1);
		Calendar startDateCal = Calendar.getInstance();
		startDateCal.setTime(date.getAsDateObject());

		Calendar endDateCal = Calendar.getInstance();
		endDateCal.setTime(startDateCal.getTime());
		endDateCal.set(Calendar.DAY_OF_MONTH, startDateCal
				.get(Calendar.DAY_OF_MONTH) - 1);

		return new FinanceDate(endDateCal.getTime());
	}

	private void createFiscalYearForExistingTransactions(
			FinanceDate transactionDate) {

		Session session = HibernateUtil.getCurrentSession();
		Query query = session
				.createQuery("from com.vimukti.accounter.core.FiscalYear f order by f.startDate");
		List list = query.list();
		// Object[] object = (Object[]) list.get(0);

		FinanceDate existingLeastStartDate = ((FiscalYear) list.get(0))
				.getStartDate();
		FinanceDate existingHighestEndDate = ((FiscalYear) list
				.get(list.size() - 1)).getEndDate();

		Calendar leastStartDateCal = Calendar.getInstance();
		leastStartDateCal.setTime(existingLeastStartDate.getAsDateObject());

		Calendar highestEndDateCal = Calendar.getInstance();
		highestEndDateCal.setTime(existingHighestEndDate.getAsDateObject());

		Calendar modifiedDateCal = Calendar.getInstance();
		modifiedDateCal.setTime(transactionDate.getAsDateObject());

		if (transactionDate.getTime() >= existingLeastStartDate.getTime()
				&& transactionDate.getTime() <= existingHighestEndDate
						.getTime()) {
			return;
		} else if (transactionDate.getTime() < existingLeastStartDate.getTime()) {

			Calendar tempCal = Calendar.getInstance();
			tempCal.setTime(leastStartDateCal.getTime());

			FinanceDate tempDate = existingLeastStartDate;

			while (tempDate.getDate() > transactionDate.getDate()) {

				Calendar cal = Calendar.getInstance();

				cal.setTime(tempCal.getTime());
				cal.set(Calendar.MONTH, tempCal.get(Calendar.MONTH) - 12);

				FinanceDate startDate = new FinanceDate(cal.getTime());

				cal.clear();
				cal.setTime(tempCal.getTime());
				cal.set(Calendar.DAY_OF_MONTH, tempCal
						.get(Calendar.DAY_OF_MONTH) - 1);

				FinanceDate endDate = new FinanceDate(cal.getTime());

				FiscalYear fs = new FiscalYear(startDate, endDate,
						FiscalYear.STATUS_OPEN, Boolean.FALSE);
				checkIsCurrentFY(fs);
				session.save(fs);
				ChangeTracker.put(fs);

				tempDate = startDate;

				tempCal.setTime(startDate.getAsDateObject());

			}

		} else if (transactionDate.getTime() > existingHighestEndDate.getTime()) {

			Calendar tempCal = Calendar.getInstance();
			tempCal.setTime(highestEndDateCal.getTime());

			FinanceDate tempDate = existingHighestEndDate;

			while (tempDate.getTime() < transactionDate.getTime()) {

				Calendar cal = Calendar.getInstance();

				cal.setTime(tempCal.getTime());
				cal.set(Calendar.DAY_OF_MONTH, tempCal
						.get(Calendar.DAY_OF_MONTH) + 1);

				FinanceDate startDate = new FinanceDate(cal.getTime());

				cal.clear();
				cal.setTime(tempCal.getTime());
				cal.set(Calendar.MONTH, tempCal.get(Calendar.MONTH) + 12);

				FinanceDate endDate = new FinanceDate(cal.getTime());
				FiscalYear fs = new FiscalYear(startDate, endDate,
						FiscalYear.STATUS_OPEN, Boolean.FALSE);
				checkIsCurrentFY(fs);
				session.save(fs);
				ChangeTracker.put(fs);

				tempDate = endDate;

				tempCal.setTime(endDate.getAsDateObject());
			}
		}
	}

	public void checkIsCurrentFY(FiscalYear fiscalYear) {
		FinanceDate presentDate = new FinanceDate();
		if (presentDate.getTime() >= fiscalYear.getStartDate().getTime()
				&& presentDate.getTime() <= fiscalYear.getEndDate().getTime())
			fiscalYear.setIsCurrentFiscalYear(true);
		else
			fiscalYear.setIsCurrentFiscalYear(false);
	}
}
